// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"sync"

	v1beta1servicecatalog "github.com/kubernetes-incubator/service-catalog/pkg/apis/servicecatalog/v1beta1"
	generated_v1beta1 "github.com/kubernetes-incubator/service-catalog/pkg/client/clientset_generated/clientset/typed/servicecatalog/v1beta1"
	"k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/watch"
)

type FakeServiceInstanceInterface struct {
	CreateStub        func(*v1beta1servicecatalog.ServiceInstance) (*v1beta1servicecatalog.ServiceInstance, error)
	createMutex       sync.RWMutex
	createArgsForCall []struct {
		arg1 *v1beta1servicecatalog.ServiceInstance
	}
	createReturns struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	createReturnsOnCall map[int]struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	UpdateStub        func(*v1beta1servicecatalog.ServiceInstance) (*v1beta1servicecatalog.ServiceInstance, error)
	updateMutex       sync.RWMutex
	updateArgsForCall []struct {
		arg1 *v1beta1servicecatalog.ServiceInstance
	}
	updateReturns struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	updateReturnsOnCall map[int]struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	UpdateStatusStub        func(*v1beta1servicecatalog.ServiceInstance) (*v1beta1servicecatalog.ServiceInstance, error)
	updateStatusMutex       sync.RWMutex
	updateStatusArgsForCall []struct {
		arg1 *v1beta1servicecatalog.ServiceInstance
	}
	updateStatusReturns struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	updateStatusReturnsOnCall map[int]struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	DeleteStub        func(name string, options *v1.DeleteOptions) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		name    string
		options *v1.DeleteOptions
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteCollectionStub        func(options *v1.DeleteOptions, listOptions v1.ListOptions) error
	deleteCollectionMutex       sync.RWMutex
	deleteCollectionArgsForCall []struct {
		options     *v1.DeleteOptions
		listOptions v1.ListOptions
	}
	deleteCollectionReturns struct {
		result1 error
	}
	deleteCollectionReturnsOnCall map[int]struct {
		result1 error
	}
	GetStub        func(name string, options v1.GetOptions) (*v1beta1servicecatalog.ServiceInstance, error)
	getMutex       sync.RWMutex
	getArgsForCall []struct {
		name    string
		options v1.GetOptions
	}
	getReturns struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	getReturnsOnCall map[int]struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	ListStub        func(opts v1.ListOptions) (*v1beta1servicecatalog.ServiceInstanceList, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		opts v1.ListOptions
	}
	listReturns struct {
		result1 *v1beta1servicecatalog.ServiceInstanceList
		result2 error
	}
	listReturnsOnCall map[int]struct {
		result1 *v1beta1servicecatalog.ServiceInstanceList
		result2 error
	}
	WatchStub        func(opts v1.ListOptions) (watch.Interface, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		opts v1.ListOptions
	}
	watchReturns struct {
		result1 watch.Interface
		result2 error
	}
	watchReturnsOnCall map[int]struct {
		result1 watch.Interface
		result2 error
	}
	PatchStub        func(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1beta1servicecatalog.ServiceInstance, err error)
	patchMutex       sync.RWMutex
	patchArgsForCall []struct {
		name         string
		pt           types.PatchType
		data         []byte
		subresources []string
	}
	patchReturns struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	patchReturnsOnCall map[int]struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	UpdateReferencesStub        func(serviceInstance *v1beta1servicecatalog.ServiceInstance) (*v1beta1servicecatalog.ServiceInstance, error)
	updateReferencesMutex       sync.RWMutex
	updateReferencesArgsForCall []struct {
		serviceInstance *v1beta1servicecatalog.ServiceInstance
	}
	updateReferencesReturns struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	updateReferencesReturnsOnCall map[int]struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeServiceInstanceInterface) Create(arg1 *v1beta1servicecatalog.ServiceInstance) (*v1beta1servicecatalog.ServiceInstance, error) {
	fake.createMutex.Lock()
	ret, specificReturn := fake.createReturnsOnCall[len(fake.createArgsForCall)]
	fake.createArgsForCall = append(fake.createArgsForCall, struct {
		arg1 *v1beta1servicecatalog.ServiceInstance
	}{arg1})
	fake.recordInvocation("Create", []interface{}{arg1})
	fake.createMutex.Unlock()
	if fake.CreateStub != nil {
		return fake.CreateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createReturns.result1, fake.createReturns.result2
}

func (fake *FakeServiceInstanceInterface) CreateCallCount() int {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return len(fake.createArgsForCall)
}

func (fake *FakeServiceInstanceInterface) CreateArgsForCall(i int) *v1beta1servicecatalog.ServiceInstance {
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	return fake.createArgsForCall[i].arg1
}

func (fake *FakeServiceInstanceInterface) CreateReturns(result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.CreateStub = nil
	fake.createReturns = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) CreateReturnsOnCall(i int, result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.CreateStub = nil
	if fake.createReturnsOnCall == nil {
		fake.createReturnsOnCall = make(map[int]struct {
			result1 *v1beta1servicecatalog.ServiceInstance
			result2 error
		})
	}
	fake.createReturnsOnCall[i] = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) Update(arg1 *v1beta1servicecatalog.ServiceInstance) (*v1beta1servicecatalog.ServiceInstance, error) {
	fake.updateMutex.Lock()
	ret, specificReturn := fake.updateReturnsOnCall[len(fake.updateArgsForCall)]
	fake.updateArgsForCall = append(fake.updateArgsForCall, struct {
		arg1 *v1beta1servicecatalog.ServiceInstance
	}{arg1})
	fake.recordInvocation("Update", []interface{}{arg1})
	fake.updateMutex.Unlock()
	if fake.UpdateStub != nil {
		return fake.UpdateStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateReturns.result1, fake.updateReturns.result2
}

func (fake *FakeServiceInstanceInterface) UpdateCallCount() int {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return len(fake.updateArgsForCall)
}

func (fake *FakeServiceInstanceInterface) UpdateArgsForCall(i int) *v1beta1servicecatalog.ServiceInstance {
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	return fake.updateArgsForCall[i].arg1
}

func (fake *FakeServiceInstanceInterface) UpdateReturns(result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.UpdateStub = nil
	fake.updateReturns = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) UpdateReturnsOnCall(i int, result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.UpdateStub = nil
	if fake.updateReturnsOnCall == nil {
		fake.updateReturnsOnCall = make(map[int]struct {
			result1 *v1beta1servicecatalog.ServiceInstance
			result2 error
		})
	}
	fake.updateReturnsOnCall[i] = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) UpdateStatus(arg1 *v1beta1servicecatalog.ServiceInstance) (*v1beta1servicecatalog.ServiceInstance, error) {
	fake.updateStatusMutex.Lock()
	ret, specificReturn := fake.updateStatusReturnsOnCall[len(fake.updateStatusArgsForCall)]
	fake.updateStatusArgsForCall = append(fake.updateStatusArgsForCall, struct {
		arg1 *v1beta1servicecatalog.ServiceInstance
	}{arg1})
	fake.recordInvocation("UpdateStatus", []interface{}{arg1})
	fake.updateStatusMutex.Unlock()
	if fake.UpdateStatusStub != nil {
		return fake.UpdateStatusStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateStatusReturns.result1, fake.updateStatusReturns.result2
}

func (fake *FakeServiceInstanceInterface) UpdateStatusCallCount() int {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return len(fake.updateStatusArgsForCall)
}

func (fake *FakeServiceInstanceInterface) UpdateStatusArgsForCall(i int) *v1beta1servicecatalog.ServiceInstance {
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	return fake.updateStatusArgsForCall[i].arg1
}

func (fake *FakeServiceInstanceInterface) UpdateStatusReturns(result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.UpdateStatusStub = nil
	fake.updateStatusReturns = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) UpdateStatusReturnsOnCall(i int, result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.UpdateStatusStub = nil
	if fake.updateStatusReturnsOnCall == nil {
		fake.updateStatusReturnsOnCall = make(map[int]struct {
			result1 *v1beta1servicecatalog.ServiceInstance
			result2 error
		})
	}
	fake.updateStatusReturnsOnCall[i] = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) Delete(name string, options *v1.DeleteOptions) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		name    string
		options *v1.DeleteOptions
	}{name, options})
	fake.recordInvocation("Delete", []interface{}{name, options})
	fake.deleteMutex.Unlock()
	if fake.DeleteStub != nil {
		return fake.DeleteStub(name, options)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteReturns.result1
}

func (fake *FakeServiceInstanceInterface) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *FakeServiceInstanceInterface) DeleteArgsForCall(i int) (string, *v1.DeleteOptions) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return fake.deleteArgsForCall[i].name, fake.deleteArgsForCall[i].options
}

func (fake *FakeServiceInstanceInterface) DeleteReturns(result1 error) {
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServiceInstanceInterface) DeleteReturnsOnCall(i int, result1 error) {
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServiceInstanceInterface) DeleteCollection(options *v1.DeleteOptions, listOptions v1.ListOptions) error {
	fake.deleteCollectionMutex.Lock()
	ret, specificReturn := fake.deleteCollectionReturnsOnCall[len(fake.deleteCollectionArgsForCall)]
	fake.deleteCollectionArgsForCall = append(fake.deleteCollectionArgsForCall, struct {
		options     *v1.DeleteOptions
		listOptions v1.ListOptions
	}{options, listOptions})
	fake.recordInvocation("DeleteCollection", []interface{}{options, listOptions})
	fake.deleteCollectionMutex.Unlock()
	if fake.DeleteCollectionStub != nil {
		return fake.DeleteCollectionStub(options, listOptions)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteCollectionReturns.result1
}

func (fake *FakeServiceInstanceInterface) DeleteCollectionCallCount() int {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return len(fake.deleteCollectionArgsForCall)
}

func (fake *FakeServiceInstanceInterface) DeleteCollectionArgsForCall(i int) (*v1.DeleteOptions, v1.ListOptions) {
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	return fake.deleteCollectionArgsForCall[i].options, fake.deleteCollectionArgsForCall[i].listOptions
}

func (fake *FakeServiceInstanceInterface) DeleteCollectionReturns(result1 error) {
	fake.DeleteCollectionStub = nil
	fake.deleteCollectionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeServiceInstanceInterface) DeleteCollectionReturnsOnCall(i int, result1 error) {
	fake.DeleteCollectionStub = nil
	if fake.deleteCollectionReturnsOnCall == nil {
		fake.deleteCollectionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteCollectionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeServiceInstanceInterface) Get(name string, options v1.GetOptions) (*v1beta1servicecatalog.ServiceInstance, error) {
	fake.getMutex.Lock()
	ret, specificReturn := fake.getReturnsOnCall[len(fake.getArgsForCall)]
	fake.getArgsForCall = append(fake.getArgsForCall, struct {
		name    string
		options v1.GetOptions
	}{name, options})
	fake.recordInvocation("Get", []interface{}{name, options})
	fake.getMutex.Unlock()
	if fake.GetStub != nil {
		return fake.GetStub(name, options)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getReturns.result1, fake.getReturns.result2
}

func (fake *FakeServiceInstanceInterface) GetCallCount() int {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return len(fake.getArgsForCall)
}

func (fake *FakeServiceInstanceInterface) GetArgsForCall(i int) (string, v1.GetOptions) {
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	return fake.getArgsForCall[i].name, fake.getArgsForCall[i].options
}

func (fake *FakeServiceInstanceInterface) GetReturns(result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.GetStub = nil
	fake.getReturns = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) GetReturnsOnCall(i int, result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.GetStub = nil
	if fake.getReturnsOnCall == nil {
		fake.getReturnsOnCall = make(map[int]struct {
			result1 *v1beta1servicecatalog.ServiceInstance
			result2 error
		})
	}
	fake.getReturnsOnCall[i] = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) List(opts v1.ListOptions) (*v1beta1servicecatalog.ServiceInstanceList, error) {
	fake.listMutex.Lock()
	ret, specificReturn := fake.listReturnsOnCall[len(fake.listArgsForCall)]
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		opts v1.ListOptions
	}{opts})
	fake.recordInvocation("List", []interface{}{opts})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listReturns.result1, fake.listReturns.result2
}

func (fake *FakeServiceInstanceInterface) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *FakeServiceInstanceInterface) ListArgsForCall(i int) v1.ListOptions {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].opts
}

func (fake *FakeServiceInstanceInterface) ListReturns(result1 *v1beta1servicecatalog.ServiceInstanceList, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 *v1beta1servicecatalog.ServiceInstanceList
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) ListReturnsOnCall(i int, result1 *v1beta1servicecatalog.ServiceInstanceList, result2 error) {
	fake.ListStub = nil
	if fake.listReturnsOnCall == nil {
		fake.listReturnsOnCall = make(map[int]struct {
			result1 *v1beta1servicecatalog.ServiceInstanceList
			result2 error
		})
	}
	fake.listReturnsOnCall[i] = struct {
		result1 *v1beta1servicecatalog.ServiceInstanceList
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) Watch(opts v1.ListOptions) (watch.Interface, error) {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		opts v1.ListOptions
	}{opts})
	fake.recordInvocation("Watch", []interface{}{opts})
	fake.watchMutex.Unlock()
	if fake.WatchStub != nil {
		return fake.WatchStub(opts)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.watchReturns.result1, fake.watchReturns.result2
}

func (fake *FakeServiceInstanceInterface) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeServiceInstanceInterface) WatchArgsForCall(i int) v1.ListOptions {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return fake.watchArgsForCall[i].opts
}

func (fake *FakeServiceInstanceInterface) WatchReturns(result1 watch.Interface, result2 error) {
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) WatchReturnsOnCall(i int, result1 watch.Interface, result2 error) {
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 watch.Interface
			result2 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 watch.Interface
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) Patch(name string, pt types.PatchType, data []byte, subresources ...string) (result *v1beta1servicecatalog.ServiceInstance, err error) {
	var dataCopy []byte
	if data != nil {
		dataCopy = make([]byte, len(data))
		copy(dataCopy, data)
	}
	fake.patchMutex.Lock()
	ret, specificReturn := fake.patchReturnsOnCall[len(fake.patchArgsForCall)]
	fake.patchArgsForCall = append(fake.patchArgsForCall, struct {
		name         string
		pt           types.PatchType
		data         []byte
		subresources []string
	}{name, pt, dataCopy, subresources})
	fake.recordInvocation("Patch", []interface{}{name, pt, dataCopy, subresources})
	fake.patchMutex.Unlock()
	if fake.PatchStub != nil {
		return fake.PatchStub(name, pt, data, subresources...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.patchReturns.result1, fake.patchReturns.result2
}

func (fake *FakeServiceInstanceInterface) PatchCallCount() int {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return len(fake.patchArgsForCall)
}

func (fake *FakeServiceInstanceInterface) PatchArgsForCall(i int) (string, types.PatchType, []byte, []string) {
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	return fake.patchArgsForCall[i].name, fake.patchArgsForCall[i].pt, fake.patchArgsForCall[i].data, fake.patchArgsForCall[i].subresources
}

func (fake *FakeServiceInstanceInterface) PatchReturns(result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.PatchStub = nil
	fake.patchReturns = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) PatchReturnsOnCall(i int, result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.PatchStub = nil
	if fake.patchReturnsOnCall == nil {
		fake.patchReturnsOnCall = make(map[int]struct {
			result1 *v1beta1servicecatalog.ServiceInstance
			result2 error
		})
	}
	fake.patchReturnsOnCall[i] = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) UpdateReferences(serviceInstance *v1beta1servicecatalog.ServiceInstance) (*v1beta1servicecatalog.ServiceInstance, error) {
	fake.updateReferencesMutex.Lock()
	ret, specificReturn := fake.updateReferencesReturnsOnCall[len(fake.updateReferencesArgsForCall)]
	fake.updateReferencesArgsForCall = append(fake.updateReferencesArgsForCall, struct {
		serviceInstance *v1beta1servicecatalog.ServiceInstance
	}{serviceInstance})
	fake.recordInvocation("UpdateReferences", []interface{}{serviceInstance})
	fake.updateReferencesMutex.Unlock()
	if fake.UpdateReferencesStub != nil {
		return fake.UpdateReferencesStub(serviceInstance)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateReferencesReturns.result1, fake.updateReferencesReturns.result2
}

func (fake *FakeServiceInstanceInterface) UpdateReferencesCallCount() int {
	fake.updateReferencesMutex.RLock()
	defer fake.updateReferencesMutex.RUnlock()
	return len(fake.updateReferencesArgsForCall)
}

func (fake *FakeServiceInstanceInterface) UpdateReferencesArgsForCall(i int) *v1beta1servicecatalog.ServiceInstance {
	fake.updateReferencesMutex.RLock()
	defer fake.updateReferencesMutex.RUnlock()
	return fake.updateReferencesArgsForCall[i].serviceInstance
}

func (fake *FakeServiceInstanceInterface) UpdateReferencesReturns(result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.UpdateReferencesStub = nil
	fake.updateReferencesReturns = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) UpdateReferencesReturnsOnCall(i int, result1 *v1beta1servicecatalog.ServiceInstance, result2 error) {
	fake.UpdateReferencesStub = nil
	if fake.updateReferencesReturnsOnCall == nil {
		fake.updateReferencesReturnsOnCall = make(map[int]struct {
			result1 *v1beta1servicecatalog.ServiceInstance
			result2 error
		})
	}
	fake.updateReferencesReturnsOnCall[i] = struct {
		result1 *v1beta1servicecatalog.ServiceInstance
		result2 error
	}{result1, result2}
}

func (fake *FakeServiceInstanceInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createMutex.RLock()
	defer fake.createMutex.RUnlock()
	fake.updateMutex.RLock()
	defer fake.updateMutex.RUnlock()
	fake.updateStatusMutex.RLock()
	defer fake.updateStatusMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.deleteCollectionMutex.RLock()
	defer fake.deleteCollectionMutex.RUnlock()
	fake.getMutex.RLock()
	defer fake.getMutex.RUnlock()
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	fake.patchMutex.RLock()
	defer fake.patchMutex.RUnlock()
	fake.updateReferencesMutex.RLock()
	defer fake.updateReferencesMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeServiceInstanceInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ generated_v1beta1.ServiceInstanceInterface = new(FakeServiceInstanceInterface)
